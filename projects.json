[
  {
    "id": "pb1",
    "title": "Number Guessing Game",
    "description": "Create a simple number guessing game where the computer generates a random number and the user tries to guess it.",
    "level": "beginner",
    "difficulty": 1,
    "skills": ["Basic syntax", "Input/Output", "Random module", "Conditionals"],
    "details": "Build a console-based number guessing game where the program generates a random number between 1 and 100. The player gets feedback after each guess whether their guess was too high or too low, until they correctly guess the number.",
    "starter_code": "import random\n\n# Generate a random number between 1 and 100\ntarget_number = random.randint(1, 100)\nattempts = 0\n\nprint(\"Welcome to the Number Guessing Game!\")\nprint(\"I'm thinking of a number between 1 and 100.\")\n\n# Your code here\n# Hint: Use a while loop to keep asking for guesses\n# Use input() to get the user's guess\n# Convert the input to an integer using int()\n# Compare the guess with target_number\n# Provide appropriate feedback\n"
  },
  {
    "id": "pb2",
    "title": "To-Do List Application",
    "description": "Build a simple command-line to-do list where users can add, view, and delete tasks.",
    "level": "beginner",
    "difficulty": 2,
    "skills": ["Lists", "Functions", "File I/O", "User input"],
    "details": "Create a command-line application that allows users to manage their to-do list. Implement functions to add tasks, view all tasks, mark tasks as completed, delete tasks, and save the tasks to a file for persistence.",
    "starter_code": "# To-Do List Application\n\ntodos = []\n\ndef show_menu():\n    print(\"\\n==== TO-DO LIST MENU ====\")\n    print(\"1. Add task\")\n    print(\"2. View tasks\")\n    print(\"3. Mark task as completed\")\n    print(\"4. Delete task\")\n    print(\"5. Save and exit\")\n    \n    choice = input(\"Enter your choice (1-5): \")\n    return choice\n\ndef add_task():\n    # Your code here\n    pass\n\ndef view_tasks():\n    # Your code here\n    pass\n\ndef complete_task():\n    # Your code here\n    pass\n\ndef delete_task():\n    # Your code here\n    pass\n\ndef save_tasks():\n    # Your code here\n    pass\n\ndef load_tasks():\n    # Your code here\n    pass\n\n# Main program\nload_tasks()  # Load any existing tasks\nwhile True:\n    user_choice = show_menu()\n    \n    # Implement the menu logic\n    # Your code here\n"
  },
  {
    "id": "pb3",
    "title": "Simple Calculator",
    "description": "Create a basic calculator that can perform addition, subtraction, multiplication, and division.",
    "level": "beginner",
    "difficulty": 1,
    "skills": ["Functions", "User input", "Conditionals", "Error handling"],
    "details": "Build a command-line calculator that prompts the user for two numbers and an operation, then displays the result. Include error handling for invalid inputs and division by zero.",
    "starter_code": "# Simple Calculator\n\ndef add(x, y):\n    return x + y\n\ndef subtract(x, y):\n    return x - y\n\ndef multiply(x, y):\n    # Your code here\n    pass\n\ndef divide(x, y):\n    # Your code here - remember to handle division by zero\n    pass\n\n# Main calculator loop\nwhile True:\n    print(\"\\nOptions:\")\n    print(\"Enter 'add' for addition\")\n    print(\"Enter 'subtract' for subtraction\")\n    print(\"Enter 'multiply' for multiplication\")\n    print(\"Enter 'divide' for division\")\n    print(\"Enter 'quit' to end the program\")\n    \n    user_input = input(\": \")\n    \n    if user_input == \"quit\":\n        break\n    \n    # Your code here to get the numbers and call the appropriate function\n"
  },
  {
    "id": "pb4",
    "title": "Password Generator",
    "description": "Create a program that generates random passwords with varying complexity.",
    "level": "beginner",
    "difficulty": 2,
    "skills": ["Random module", "Strings", "Functions", "User input"],
    "details": "Build a password generator that creates random passwords based on user-specified criteria such as length and inclusion of uppercase letters, lowercase letters, numbers, and special characters.",
    "starter_code": "import random\nimport string\n\ndef generate_password(length, use_uppercase, use_numbers, use_special):\n    # Define character sets\n    lowercase_chars = string.ascii_lowercase\n    uppercase_chars = string.ascii_uppercase\n    number_chars = string.digits\n    special_chars = string.punctuation\n    \n    # Create a pool of characters based on selected options\n    # Your code here\n    \n    # Generate and return the password\n    # Your code here\n    \n# Main program\nprint(\"Welcome to Password Generator!\")\n\n# Get user preferences\n# Your code here\n\n# Generate and display password\n# Your code here\n"
  },
  {
    "id": "pi1",
    "title": "Weather App",
    "description": "Build a command-line application that fetches and displays weather data for a given location.",
    "level": "intermediate",
    "difficulty": 3,
    "skills": ["APIs", "JSON", "Error handling", "Data formatting"],
    "details": "Create a weather application that takes a city name or ZIP code as input, fetches weather data from a free API, and displays current conditions, temperature, and forecast in a user-friendly format.",
    "starter_code": "import requests\nimport json\n\ndef get_weather(location):\n    # Use a free weather API like OpenWeatherMap\n    # You'll need to use the requests library to fetch data\n    # Parse the JSON response and extract relevant information\n    # Return formatted weather data\n    pass\n\ndef display_weather(weather_data):\n    # Format and display the weather information in a user-friendly way\n    pass\n\ndef main():\n    print(\"Weather Information App\")\n    location = input(\"Enter city name or ZIP code: \")\n    \n    try:\n        weather_data = get_weather(location)\n        display_weather(weather_data)\n    except Exception as e:\n        print(f\"An error occurred: {e}\")\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "id": "pi2",
    "title": "Web Scraper",
    "description": "Build a web scraper that extracts specific information from websites.",
    "level": "intermediate",
    "difficulty": 3,
    "skills": ["Web scraping", "BeautifulSoup/Requests", "HTML/CSS basics", "Data extraction"],
    "details": "Create a program that scrapes information from a selected website (e.g., news headlines, product prices, or weather forecasts). The scraper should extract specific data elements, format them, and save them to a file or display them in a structured way.",
    "starter_code": "import requests\nfrom bs4 import BeautifulSoup\n\ndef scrape_website(url, target_element, target_class=None):\n    # Fetch the web page\n    response = requests.get(url)\n    \n    # Check if the request was successful\n    if response.status_code == 200:\n        # Parse the HTML content\n        soup = BeautifulSoup(response.text, 'html.parser')\n        \n        # Find the target elements\n        # Your code here\n        \n        # Extract and return the desired information\n        # Your code here\n    else:\n        print(f\"Failed to retrieve the webpage. Status code: {response.status_code}\")\n        return None\n\ndef main():\n    # Example: Scraping news headlines\n    print(\"Web Scraper\")\n    url = input(\"Enter the URL to scrape: \")\n    element = input(\"Enter the HTML element to target (e.g., div, h2, p): \")\n    class_name = input(\"Enter the class name (optional): \")\n    \n    results = scrape_website(url, element, class_name)\n    \n    # Process and display the results\n    # Your code here\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "id": "pi3",
    "title": "Personal Finance Tracker",
    "description": "Create an application to track personal expenses and income.",
    "level": "intermediate",
    "difficulty": 3,
    "skills": ["File I/O", "Data structures", "Data visualization", "OOP"],
    "details": "Build a personal finance tracker that allows users to record expenses and income, categorize transactions, and generate reports. The application should store transaction history in a file and provide summary statistics and basic visualizations of spending patterns.",
    "starter_code": "import json\nimport os\nfrom datetime import datetime\nimport matplotlib.pyplot as plt\n\nclass Transaction:\n    def __init__(self, amount, category, description, date=None, transaction_type=\"expense\"):\n        # Initialize transaction attributes\n        # Your code here\n        pass\n    \n    def __str__(self):\n        # Return a string representation of the transaction\n        # Your code here\n        pass\n\nclass FinanceTracker:\n    def __init__(self, filename=\"finances.json\"):\n        # Initialize the tracker\n        # Your code here\n        pass\n    \n    def add_transaction(self, transaction):\n        # Add a transaction to the list\n        # Your code here\n        pass\n    \n    def get_balance(self):\n        # Calculate and return current balance\n        # Your code here\n        pass\n    \n    def get_summary_by_category(self):\n        # Summarize transactions by category\n        # Your code here\n        pass\n    \n    def save_to_file(self):\n        # Save transactions to file\n        # Your code here\n        pass\n    \n    def load_from_file(self):\n        # Load transactions from file\n        # Your code here\n        pass\n    \n    def generate_report(self):\n        # Generate a report of finances\n        # Your code here\n        pass\n    \n    def visualize_expenses(self):\n        # Create visualizations of spending patterns\n        # Your code here\n        pass\n\n# Main application\ndef main():\n    tracker = FinanceTracker()\n    tracker.load_from_file()\n    \n    # Implement the user interface\n    # Your code here\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "id": "pi4",
    "title": "URL Shortener",
    "description": "Create a URL shortening service like bit.ly.",
    "level": "intermediate",
    "difficulty": 4,
    "skills": ["Web development", "Databases", "Flask/Django", "Unique ID generation"],
    "details": "Build a basic URL shortening service that takes long URLs and creates shorter, more manageable links. The system should store the mapping between short and long URLs and redirect users who visit the short URL to the original long URL.",
    "starter_code": "from flask import Flask, request, redirect, render_template, url_for\nimport string\nimport random\nimport json\nimport os\n\napp = Flask(__name__)\n\n# In a real application, you would use a database\n# For simplicity, we'll use a JSON file\nURL_DB_FILE = \"urls.json\"\n\ndef load_urls():\n    if os.path.exists(URL_DB_FILE):\n        with open(URL_DB_FILE, 'r') as f:\n            return json.load(f)\n    return {}\n\ndef save_urls(urls):\n    with open(URL_DB_FILE, 'w') as f:\n        json.dump(urls, f)\n\ndef generate_short_code(length=6):\n    # Generate a random short code\n    # Your code here\n    pass\n\n@app.route('/')\ndef index():\n    # Render the home page with a form for URL submission\n    # Your code here\n    pass\n\n@app.route('/shorten', methods=['POST'])\ndef shorten():\n    # Get the URL from the form\n    # Generate a short code\n    # Save the mapping\n    # Return the shortened URL\n    # Your code here\n    pass\n\n@app.route('/<short_code>')\ndef redirect_to_url(short_code):\n    # Look up the short code and redirect to the original URL\n    # Your code here\n    pass\n\nif __name__ == '__main__':\n    app.run(debug=True, host='0.0.0.0', port=5000)\n"
  },
  {
    "id": "pa1",
    "title": "Machine Learning Image Classifier",
    "description": "Build an image classification system using machine learning.",
    "level": "advanced",
    "difficulty": 5,
    "skills": ["Machine learning", "TensorFlow/PyTorch", "Neural networks", "Image processing"],
    "details": "Create an image classification system that can identify objects in images. Use a pre-trained model like ResNet or VGG16 and fine-tune it for your specific classification task. Implement a user interface that allows users to upload images and receive predictions.",
    "starter_code": "import tensorflow as tf\nfrom tensorflow.keras.applications import MobileNetV2\nfrom tensorflow.keras.preprocessing import image\nfrom tensorflow.keras.applications.mobilenet_v2 import preprocess_input, decode_predictions\nimport numpy as np\n\ndef load_model():\n    # Load a pre-trained model\n    model = MobileNetV2(weights='imagenet')\n    return model\n\ndef preprocess_image(img_path):\n    # Load and preprocess an image\n    img = image.load_img(img_path, target_size=(224, 224))\n    x = image.img_to_array(img)\n    x = np.expand_dims(x, axis=0)\n    x = preprocess_input(x)\n    return x\n\ndef predict(model, img):\n    # Make a prediction\n    preds = model.predict(img)\n    results = decode_predictions(preds, top=5)[0]\n    return results\n\ndef main():\n    # Load the model\n    model = load_model()\n    \n    # Get image path from user\n    img_path = input(\"Enter path to image: \")\n    \n    # Preprocess the image\n    preprocessed_img = preprocess_image(img_path)\n    \n    # Make predictions\n    results = predict(model, preprocessed_img)\n    \n    # Display results\n    print(\"Top predictions:\")\n    for i, (imagenet_id, label, score) in enumerate(results):\n        print(f\"{i+1}: {label} ({score:.2f})\")\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "id": "pa2",
    "title": "Natural Language Processing Chatbot",
    "description": "Build a chatbot that can understand and respond to natural language inputs.",
    "level": "advanced",
    "difficulty": 5,
    "skills": ["NLP", "NLTK/spaCy", "Text processing", "Dialog management"],
    "details": "Develop a chatbot that can understand user inputs using natural language processing techniques. The chatbot should be able to extract intent and entities from user messages, maintain context across multiple turns of conversation, and generate appropriate responses.",
    "starter_code": "import nltk\nfrom nltk.tokenize import word_tokenize\nfrom nltk.stem import WordNetLemmatizer\nfrom nltk.corpus import stopwords\nimport string\nimport random\nimport json\n\n# Download necessary NLTK data\nnltk.download('punkt')\nnltk.download('wordnet')\nnltk.download('stopwords')\n\nclass Chatbot:\n    def __init__(self, knowledge_base_file=\"knowledge_base.json\"):\n        # Initialize the chatbot with a knowledge base\n        self.lemmatizer = WordNetLemmatizer()\n        self.stop_words = set(stopwords.words('english'))\n        self.load_knowledge_base(knowledge_base_file)\n        self.context = {}\n    \n    def load_knowledge_base(self, file_path):\n        # Load the knowledge base from a JSON file\n        try:\n            with open(file_path, 'r') as f:\n                self.knowledge_base = json.load(f)\n        except FileNotFoundError:\n            # Create a basic knowledge base if file not found\n            self.knowledge_base = {\n                \"intents\": [\n                    {\n                        \"tag\": \"greeting\",\n                        \"patterns\": [\"Hi\", \"Hello\", \"Hey\", \"How are you\", \"Greetings\"],\n                        \"responses\": [\"Hello!\", \"Hi there!\", \"Hey! How can I help you today?\"]\n                    },\n                    {\n                        \"tag\": \"goodbye\",\n                        \"patterns\": [\"Bye\", \"See you\", \"Goodbye\", \"I'm leaving\"],\n                        \"responses\": [\"Goodbye!\", \"See you later!\", \"Have a nice day!\"]\n                    },\n                    {\n                        \"tag\": \"thanks\",\n                        \"patterns\": [\"Thanks\", \"Thank you\", \"That's helpful\"],\n                        \"responses\": [\"You're welcome!\", \"Happy to help!\", \"Anytime!\"]\n                    }\n                ]\n            }\n            self.save_knowledge_base(file_path)\n    \n    def save_knowledge_base(self, file_path):\n        # Save the knowledge base to a file\n        with open(file_path, 'w') as f:\n            json.dump(self.knowledge_base, f, indent=4)\n    \n    def preprocess(self, text):\n        # Tokenize, remove punctuation, lemmatize, and remove stop words\n        # Your code here\n        pass\n    \n    def extract_intent(self, text):\n        # Extract the intent from user input\n        # Your code here\n        pass\n    \n    def generate_response(self, intent):\n        # Generate a response based on the intent\n        # Your code here\n        pass\n    \n    def process_input(self, user_input):\n        # Process user input and generate a response\n        # Your code here\n        pass\n\ndef main():\n    chatbot = Chatbot()\n    print(\"Chatbot: Hello! How can I help you today? (type 'quit' to exit)\")\n    \n    while True:\n        user_input = input(\"You: \")\n        if user_input.lower() == 'quit':\n            print(\"Chatbot: Goodbye!\")\n            break\n        \n        response = chatbot.process_input(user_input)\n        print(f\"Chatbot: {response}\")\n\nif __name__ == \"__main__\":\n    main()\n"
  },
  {
    "id": "pa3",
    "title": "Web Application with Django",
    "description": "Build a full-featured web application using Django.",
    "level": "advanced",
    "difficulty": 4,
    "skills": ["Django", "Databases", "Web development", "Authentication"],
    "details": "Create a complete web application with Django. Include user authentication, database models for storing application data, forms for user input, and views for displaying information. Implement a responsive frontend using Django templates and CSS.",
    "starter_code": "# This is a simplified guide for a Django project\n# In a real implementation, you'd need multiple files in different directories\n\n# 1. Create a new Django project:\n# django-admin startproject myproject\n\n# 2. Create a new app:\n# cd myproject\n# python manage.py startapp myapp\n\n# 3. Define models in myapp/models.py:\nfrom django.db import models\nfrom django.contrib.auth.models import User\n\nclass Profile(models.Model):\n    user = models.OneToOneField(User, on_delete=models.CASCADE)\n    bio = models.TextField(max_length=500, blank=True)\n    location = models.CharField(max_length=30, blank=True)\n    birth_date = models.DateField(null=True, blank=True)\n    \n    def __str__(self):\n        return self.user.username\n\nclass Item(models.Model):\n    name = models.CharField(max_length=100)\n    description = models.TextField()\n    created_at = models.DateTimeField(auto_now_add=True)\n    created_by = models.ForeignKey(User, on_delete=models.CASCADE)\n    \n    def __str__(self):\n        return self.name\n\n# 4. Create forms in myapp/forms.py:\nfrom django import forms\nfrom .models import Profile, Item\n\nclass ProfileForm(forms.ModelForm):\n    class Meta:\n        model = Profile\n        fields = ['bio', 'location', 'birth_date']\n\nclass ItemForm(forms.ModelForm):\n    class Meta:\n        model = Item\n        fields = ['name', 'description']\n\n# 5. Define views in myapp/views.py:\nfrom django.shortcuts import render, redirect, get_object_or_404\nfrom django.contrib.auth.decorators import login_required\nfrom .models import Profile, Item\nfrom .forms import ProfileForm, ItemForm\n\ndef home(request):\n    items = Item.objects.all().order_by('-created_at')\n    return render(request, 'myapp/home.html', {'items': items})\n\n@login_required\ndef profile(request):\n    profile = get_object_or_404(Profile, user=request.user)\n    if request.method == 'POST':\n        form = ProfileForm(request.POST, instance=profile)\n        if form.is_valid():\n            form.save()\n            return redirect('profile')\n    else:\n        form = ProfileForm(instance=profile)\n    return render(request, 'myapp/profile.html', {'form': form})\n\n@login_required\ndef add_item(request):\n    if request.method == 'POST':\n        form = ItemForm(request.POST)\n        if form.is_valid():\n            item = form.save(commit=False)\n            item.created_by = request.user\n            item.save()\n            return redirect('home')\n    else:\n        form = ItemForm()\n    return render(request, 'myapp/add_item.html', {'form': form})\n\n# 6. Configure URLs in myapp/urls.py:\nfrom django.urls import path\nfrom . import views\n\nurlpatterns = [\n    path('', views.home, name='home'),\n    path('profile/', views.profile, name='profile'),\n    path('add-item/', views.add_item, name='add_item'),\n]\n\n# 7. Update project URLs in myproject/urls.py:\nfrom django.contrib import admin\nfrom django.urls import path, include\n\nurlpatterns = [\n    path('admin/', admin.site.urls),\n    path('', include('myapp.urls')),\n    path('accounts/', include('django.contrib.auth.urls')),\n]\n\n# 8. Create templates in myapp/templates/myapp/\n# (home.html, profile.html, add_item.html)\n\n# 9. Configure settings in myproject/settings.py\n\n# 10. Run migrations:\n# python manage.py makemigrations\n# python manage.py migrate\n\n# 11. Create a superuser:\n# python manage.py createsuperuser\n\n# 12. Run the development server:\n# python manage.py runserver\n"
  },
  {
    "id": "pa4",
    "title": "Data Analysis and Visualization Dashboard",
    "description": "Create a dashboard for analyzing and visualizing datasets.",
    "level": "advanced",
    "difficulty": 4,
    "skills": ["Data analysis", "Pandas", "Matplotlib/Plotly", "Dashboard design"],
    "details": "Build a data analysis and visualization dashboard that allows users to upload datasets, perform exploratory data analysis, and generate interactive visualizations. The dashboard should provide insights into the dataset through summary statistics, correlation analysis, and various chart types.",
    "starter_code": "import pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nimport streamlit as st\nimport io\nimport numpy as np\n\ndef load_data(file):\n    # Load data from various file formats\n    if file.name.endswith('.csv'):\n        return pd.read_csv(file)\n    elif file.name.endswith('.xlsx'):\n        return pd.read_excel(file)\n    elif file.name.endswith('.json'):\n        return pd.read_json(file)\n    else:\n        st.error(\"Unsupported file format\")\n        return None\n\ndef explore_data(df):\n    # Display basic information about the dataset\n    st.subheader(\"Dataset Overview\")\n    st.write(f\"Shape: {df.shape[0]} rows, {df.shape[1]} columns\")\n    \n    st.subheader(\"Sample Data\")\n    st.dataframe(df.head())\n    \n    st.subheader(\"Data Types\")\n    st.write(df.dtypes)\n    \n    st.subheader(\"Summary Statistics\")\n    st.write(df.describe())\n    \n    # Check for missing values\n    st.subheader(\"Missing Values\")\n    missing = df.isnull().sum()\n    if missing.sum() > 0:\n        st.write(missing[missing > 0])\n    else:\n        st.write(\"No missing values\")\n\ndef visualize_data(df):\n    # Create visualizations based on the dataset\n    st.subheader(\"Data Visualization\")\n    \n    # Select columns for visualization\n    numeric_cols = df.select_dtypes(include=['int64', 'float64']).columns.tolist()\n    categorical_cols = df.select_dtypes(include=['object', 'category']).columns.tolist()\n    \n    # Visualization type selector\n    viz_type = st.selectbox(\"Select Visualization Type\", \n                           [\"Distribution\", \"Correlation\", \"Categorical Analysis\", \"Time Series\"])\n    \n    if viz_type == \"Distribution\":\n        if numeric_cols:\n            col = st.selectbox(\"Select column\", numeric_cols)\n            st.subheader(f\"Distribution of {col}\")\n            fig, ax = plt.subplots(figsize=(10, 6))\n            sns.histplot(df[col].dropna(), kde=True, ax=ax)\n            st.pyplot(fig)\n            \n            st.subheader(\"Box Plot\")\n            fig, ax = plt.subplots(figsize=(10, 6))\n            sns.boxplot(y=df[col], ax=ax)\n            st.pyplot(fig)\n        else:\n            st.write(\"No numeric columns available for distribution analysis\")\n    \n    elif viz_type == \"Correlation\":\n        if len(numeric_cols) > 1:\n            st.subheader(\"Correlation Heatmap\")\n            fig, ax = plt.subplots(figsize=(12, 10))\n            corr = df[numeric_cols].corr()\n            sns.heatmap(corr, annot=True, cmap='coolwarm', linewidths=0.5, ax=ax)\n            st.pyplot(fig)\n            \n            st.subheader(\"Scatter Plot\")\n            col1 = st.selectbox(\"Select X-axis\", numeric_cols)\n            col2 = st.selectbox(\"Select Y-axis\", [col for col in numeric_cols if col != col1])\n            fig, ax = plt.subplots(figsize=(10, 6))\n            sns.scatterplot(x=df[col1], y=df[col2], ax=ax)\n            st.pyplot(fig)\n        else:\n            st.write(\"Need at least two numeric columns for correlation analysis\")\n    \n    elif viz_type == \"Categorical Analysis\":\n        if categorical_cols:\n            cat_col = st.selectbox(\"Select categorical column\", categorical_cols)\n            st.subheader(f\"Value Counts for {cat_col}\")\n            fig, ax = plt.subplots(figsize=(10, 6))\n            df[cat_col].value_counts().plot(kind='bar', ax=ax)\n            st.pyplot(fig)\n            \n            if numeric_cols:\n                num_col = st.selectbox(\"Select numeric column for comparison\", numeric_cols)\n                st.subheader(f\"{num_col} by {cat_col}\")\n                fig, ax = plt.subplots(figsize=(12, 8))\n                sns.boxplot(x=cat_col, y=num_col, data=df, ax=ax)\n                plt.xticks(rotation=45)\n                st.pyplot(fig)\n        else:\n            st.write(\"No categorical columns available for analysis\")\n    \n    elif viz_type == \"Time Series\":\n        # Check if dataframe has any datetime columns\n        date_cols = df.select_dtypes(include=['datetime64']).columns.tolist()\n        if not date_cols:\n            # Try to convert object columns to datetime\n            for col in df.select_dtypes(include=['object']).columns:\n                try:\n                    df[col] = pd.to_datetime(df[col])\n                    date_cols.append(col)\n                except:\n                    pass\n        \n        if date_cols:\n            date_col = st.selectbox(\"Select date column\", date_cols)\n            if numeric_cols:\n                value_col = st.selectbox(\"Select value column\", numeric_cols)\n                st.subheader(f\"Time Series: {value_col} over {date_col}\")\n                \n                # Resample to appropriate time period\n                df_sorted = df.sort_values(by=date_col)\n                fig, ax = plt.subplots(figsize=(12, 6))\n                plt.plot(df_sorted[date_col], df_sorted[value_col])\n                plt.xticks(rotation=45)\n                st.pyplot(fig)\n            else:\n                st.write(\"No numeric columns available for time series\")\n        else:\n            st.write(\"No date columns available for time series analysis\")\n\ndef main():\n    st.title(\"Data Analysis and Visualization Dashboard\")\n    st.write(\"Upload a dataset to begin analysis\")\n    \n    uploaded_file = st.file_uploader(\"Choose a file\", type=[\"csv\", \"xlsx\", \"json\"])\n    if uploaded_file is not None:\n        df = load_data(uploaded_file)\n        if df is not None:\n            # Create tabs for different analysis views\n            tab1, tab2, tab3 = st.tabs([\"Data Explorer\", \"Visualization\", \"Insights\"])\n            \n            with tab1:\n                explore_data(df)\n            \n            with tab2:\n                visualize_data(df)\n            \n            with tab3:\n                st.subheader(\"Automated Insights\")\n                # Generate automated insights based on the dataset\n                # Your code here\n\nif __name__ == \"__main__\":\n    main()\n"
  }
]
